const STA2D_GEO: [[(usize, f32); 8]; 8] = [
    [(0,  1.0), (1,  1.0), (2,  1.0), (3,  1.0), (4,  1.0), (5,  1.0), (6,  1.0), (7,  1.0)],
    [(1,  1.0), (0,  1.0), (4,  1.0), (5,  1.0), (2,  1.0), (3,  1.0), (7,  1.0), (6,  1.0)],
    [(2,  1.0), (4, -1.0), (0, -1.0), (6,  1.0), (1,  1.0), (7, -1.0), (3, -1.0), (5,  1.0)],
    [(3,  1.0), (5, -1.0), (6, -1.0), (0, -1.0), (7,  1.0), (1,  1.0), (2,  1.0), (4, -1.0)],
    [(4,  1.0), (2, -1.0), (1, -1.0), (7,  1.0), (0,  1.0), (6, -1.0), (5, -1.0), (3,  1.0)],
    [(5,  1.0), (3, -1.0), (7, -1.0), (1, -1.0), (6,  1.0), (0,  1.0), (4,  1.0), (2, -1.0)],
    [(6,  1.0), (7,  1.0), (3,  1.0), (2, -1.0), (5,  1.0), (4, -1.0), (0, -1.0), (1, -1.0)],
    [(7,  1.0), (6,  1.0), (5,  1.0), (4, -1.0), (3,  1.0), (2, -1.0), (1, -1.0), (0, -1.0)],
];

fn mult(v1: [f32; 8], v2: [f32; 8]) -> [f32; 8] {
    let mut v3 = [0.0; 8];

    for i in 0..v1.len() {
        for j in 0..v2.len() {
            v3[STA2D_GEO[i][j].0] += STA2D_GEO[i][j].1 * v1[i] * v2[j];
        }
    }

    v3
}

fn exp(bv1: f32, bv2: f32, bv3: f32) -> ([f32; 8], [f32; 8]) {
    (
        mult(mult(
            [bv1.cosh(), 0.0, 0.0, 0.0, bv1.sinh(), 0.0, 0.0, 0.0],
            [bv2.cosh(), 0.0, 0.0, 0.0, 0.0, bv2.sinh(), 0.0, 0.0]),
            [bv3.cos(), 0.0, 0.0, 0.0, 0.0, 0.0, bv3.sin(), 0.0]
        ),
        mult(mult(
            [(-bv1).cosh(), 0.0, 0.0, 0.0, (-bv1).sinh(), 0.0, 0.0, 0.0],
            [(-bv2).cosh(), 0.0, 0.0, 0.0, 0.0, (-bv2).sinh(), 0.0, 0.0]),
            [(-bv3).cos(), 0.0, 0.0, 0.0, 0.0, 0.0, (-bv3).sin(), 0.0]
        )
    )
}

pub fn boost(vx: f32, vy: f32, vectors: Vec<&mut [f32; 8]>) {
    let rotors = exp(vx, vy, 0.0);

    for vector in vectors.into_iter() {
        *vector = mult(rotors.0, mult(*vector, rotors.1));
    }
}

#[test]
fn test_sta2d() {
    let mut v = [0.0; 8];
    v[1] = 1.0;
    v[2] = 2.0;
    v[3] = 0.0;

    boost(-2.0, 0.0, vec![&mut v]);

    let rotors = exp(-1.0, 1.0, 0.0);

    println!("{:?}", v);
}